/*
 * generated by Xtext
 */
package hu.elte.txtuml.xtxtuml.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import hu.elte.txtuml.xtxtuml.services.XtxtUMLGrammarAccess;
import hu.elte.txtuml.xtxtuml.xtxtUML.RAlfAssocNavExpression;
import hu.elte.txtuml.xtxtuml.xtxtUML.RAlfDeleteObjectExpression;
import hu.elte.txtuml.xtxtuml.xtxtUML.RAlfSendSignalExpression;
import hu.elte.txtuml.xtxtuml.xtxtUML.RAlfSignalAccessExpression;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUAssociation;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUAssociationEnd;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUAttribute;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUAttributeOrOperationDeclarationPrefix;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUClass;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUConstructor;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUEntryOrExitActivity;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUExecution;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUFile;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUModelDeclaration;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUMultiplicity;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUOperation;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUSignal;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUSignalAttribute;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUState;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUTransition;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUTransitionEffect;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUTransitionGuard;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUTransitionTrigger;
import hu.elte.txtuml.xtxtuml.xtxtUML.TUTransitionVertex;
import hu.elte.txtuml.xtxtuml.xtxtUML.XtxtUMLPackage;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.serializer.XbaseSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;

@SuppressWarnings("all")
public class XtxtUMLSemanticSequencer extends XbaseSemanticSequencer {

	@Inject
	private XtxtUMLGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == TypesPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_FORMAL_PARAMETER:
				if(context == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_LOWER_BOUND:
				if(context == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				if(context == grammarAccess.getJvmParameterizedTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getJvmArgumentTypeReferenceRule() ||
				   context == grammarAccess.getJvmTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference_JvmSimpleTypeReference_JvmTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getJvmSimpleTypeReferenceRule()) {
					sequence_JvmSimpleTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if(context == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == XbasePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case XbasePackage.XASSIGNMENT:
				sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
				return; 
			case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
				sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XBINARY_OPERATION:
				sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
				return; 
			case XbasePackage.XBLOCK_EXPRESSION:
				if(context == grammarAccess.getXBlockExpressionRule() ||
				   context == grammarAccess.getXRAlfStatementRule() ||
				   context == grammarAccess.getXRAlfStatementSemicolonNotNeededRule()) {
					sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getXExpressionInClosureRule()) {
					sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XBOOLEAN_LITERAL:
				sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
				return; 
			case XbasePackage.XCASE_PART:
				sequence_XCasePart(context, (XCasePart) semanticObject); 
				return; 
			case XbasePackage.XCASTED_EXPRESSION:
				sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
				return; 
			case XbasePackage.XCATCH_CLAUSE:
				sequence_XCatchClause(context, (XCatchClause) semanticObject); 
				return; 
			case XbasePackage.XCLOSURE:
				if(context == grammarAccess.getXClosureRule()) {
					sequence_XClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getXShortClosureRule()) {
					sequence_XShortClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XCONSTRUCTOR_CALL:
				sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
				return; 
			case XbasePackage.XDO_WHILE_EXPRESSION:
				sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
				return; 
			case XbasePackage.XFEATURE_CALL:
				sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XFOR_LOOP_EXPRESSION:
				sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XIF_EXPRESSION:
				sequence_XIfExpression(context, (XIfExpression) semanticObject); 
				return; 
			case XbasePackage.XINSTANCE_OF_EXPRESSION:
				sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
				return; 
			case XbasePackage.XLIST_LITERAL:
				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
				return; 
			case XbasePackage.XMEMBER_FEATURE_CALL:
				sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XNULL_LITERAL:
				sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
				return; 
			case XbasePackage.XNUMBER_LITERAL:
				sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
				return; 
			case XbasePackage.XPOSTFIX_OPERATION:
				sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
				return; 
			case XbasePackage.XRETURN_EXPRESSION:
				sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
				return; 
			case XbasePackage.XSET_LITERAL:
				sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
				return; 
			case XbasePackage.XSTRING_LITERAL:
				sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
				return; 
			case XbasePackage.XSWITCH_EXPRESSION:
				sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
				return; 
			case XbasePackage.XSYNCHRONIZED_EXPRESSION:
				sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
				return; 
			case XbasePackage.XTHROW_EXPRESSION:
				sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
				return; 
			case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
				sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
				return; 
			case XbasePackage.XTYPE_LITERAL:
				sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
				return; 
			case XbasePackage.XUNARY_OPERATION:
				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
				return; 
			case XbasePackage.XVARIABLE_DECLARATION:
				sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
				return; 
			case XbasePackage.XWHILE_EXPRESSION:
				sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == XtxtUMLPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case XtxtUMLPackage.RALF_ASSOC_NAV_EXPRESSION:
				sequence_XMemberFeatureCall(context, (RAlfAssocNavExpression) semanticObject); 
				return; 
			case XtxtUMLPackage.RALF_DELETE_OBJECT_EXPRESSION:
				sequence_RAlfDeleteObjectExpression(context, (RAlfDeleteObjectExpression) semanticObject); 
				return; 
			case XtxtUMLPackage.RALF_SEND_SIGNAL_EXPRESSION:
				sequence_RAlfSendSignalExpression(context, (RAlfSendSignalExpression) semanticObject); 
				return; 
			case XtxtUMLPackage.RALF_SIGNAL_ACCESS_EXPRESSION:
				sequence_RAlfSignalAccessExpression(context, (RAlfSignalAccessExpression) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_ASSOCIATION:
				sequence_TUAssociation(context, (TUAssociation) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_ASSOCIATION_END:
				sequence_TUAssociationEnd(context, (TUAssociationEnd) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_ATTRIBUTE:
				sequence_TUClassMember(context, (TUAttribute) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_ATTRIBUTE_OR_OPERATION_DECLARATION_PREFIX:
				sequence_TUAttributeOrOperationDeclarationPrefix(context, (TUAttributeOrOperationDeclarationPrefix) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_CLASS:
				sequence_TUClass(context, (TUClass) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_CONSTRUCTOR:
				sequence_TUConstructor(context, (TUConstructor) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_ENTRY_OR_EXIT_ACTIVITY:
				sequence_TUEntryOrExitActivity(context, (TUEntryOrExitActivity) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_EXECUTION:
				sequence_TUExecution(context, (TUExecution) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_FILE:
				sequence_TUFile(context, (TUFile) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_MODEL_DECLARATION:
				sequence_TUModelDeclaration(context, (TUModelDeclaration) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_MULTIPLICITY:
				sequence_TUMultiplicity(context, (TUMultiplicity) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_OPERATION:
				sequence_TUClassMember(context, (TUOperation) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_SIGNAL:
				sequence_TUSignal(context, (TUSignal) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_SIGNAL_ATTRIBUTE:
				sequence_TUSignalAttribute(context, (TUSignalAttribute) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_STATE:
				sequence_TUState(context, (TUState) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_TRANSITION:
				sequence_TUTransition(context, (TUTransition) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_TRANSITION_EFFECT:
				sequence_TUTransitionEffect(context, (TUTransitionEffect) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_TRANSITION_GUARD:
				sequence_TUTransitionGuard(context, (TUTransitionGuard) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_TRANSITION_TRIGGER:
				sequence_TUTransitionTrigger(context, (TUTransitionTrigger) semanticObject); 
				return; 
			case XtxtUMLPackage.TU_TRANSITION_VERTEX:
				sequence_TUTransitionVertex(context, (TUTransitionVertex) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == XtypePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (type=[JvmType|QualifiedName] arguments+=JvmSimpleTypeReference)
	 */
	protected void sequence_JvmParameterizedTypeReference(EObject context, JvmParameterizedTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((type=[JvmType|QualifiedName] arguments+=JvmSimpleTypeReference) | type=[JvmType|QualifiedName])
	 */
	protected void sequence_JvmParameterizedTypeReference_JvmSimpleTypeReference_JvmTypeReference(EObject context, JvmParameterizedTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=[JvmType|QualifiedName]
	 */
	protected void sequence_JvmSimpleTypeReference(EObject context, JvmParameterizedTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     object=XExpression
	 */
	protected void sequence_RAlfDeleteObjectExpression(EObject context, RAlfDeleteObjectExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.RALF_DELETE_OBJECT_EXPRESSION__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.RALF_DELETE_OBJECT_EXPRESSION__OBJECT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRAlfDeleteObjectExpressionAccess().getObjectXExpressionParserRuleCall_2_0(), semanticObject.getObject());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (signal=XExpression target=XExpression)
	 */
	protected void sequence_RAlfSendSignalExpression(EObject context, RAlfSendSignalExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.RALF_SEND_SIGNAL_EXPRESSION__SIGNAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.RALF_SEND_SIGNAL_EXPRESSION__SIGNAL));
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.RALF_SEND_SIGNAL_EXPRESSION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.RALF_SEND_SIGNAL_EXPRESSION__TARGET));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRAlfSendSignalExpressionAccess().getSignalXExpressionParserRuleCall_2_0(), semanticObject.getSignal());
		feeder.accept(grammarAccess.getRAlfSendSignalExpressionAccess().getTargetXExpressionParserRuleCall_4_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     sigdata='sigdata'
	 */
	protected void sequence_RAlfSignalAccessExpression(EObject context, RAlfSignalAccessExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.RALF_SIGNAL_ACCESS_EXPRESSION__SIGDATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.RALF_SIGNAL_ACCESS_EXPRESSION__SIGDATA));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRAlfSignalAccessExpressionAccess().getSigdataSigdataKeyword_1_0(), semanticObject.getSigdata());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (visibility=TUVisibility? notNavigable?='hidden'? multiplicity=TUMultiplicity endClass=[TUClass|QualifiedName] name=ValidID)
	 */
	protected void sequence_TUAssociationEnd(EObject context, TUAssociationEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID ends+=TUAssociationEnd*)
	 */
	protected void sequence_TUAssociation(EObject context, TUAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (visibility=TUVisibility? type=JvmTypeReference)
	 */
	protected void sequence_TUAttributeOrOperationDeclarationPrefix(EObject context, TUAttributeOrOperationDeclarationPrefix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (prefix=TUClassMember_TUAttribute_1_1_0_0 name=ValidID)
	 */
	protected void sequence_TUClassMember(EObject context, TUAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.TU_ATTRIBUTE__PREFIX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.TU_ATTRIBUTE__PREFIX));
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.TU_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.TU_ATTRIBUTE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTUClassMemberAccess().getTUAttributePrefixAction_1_1_0_0(), semanticObject.getPrefix());
		feeder.accept(grammarAccess.getTUClassMemberAccess().getNameValidIDParserRuleCall_1_1_0_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         prefix=TUClassMember_TUOperation_1_1_1_0 
	 *         name=ValidID 
	 *         (parameters+=FullJvmFormalParameter parameters+=FullJvmFormalParameter*)? 
	 *         body=XBlockExpression
	 *     )
	 */
	protected void sequence_TUClassMember(EObject context, TUOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID superClass=[TUClass|QualifiedName]? members+=TUClassMember*)
	 */
	protected void sequence_TUClass(EObject context, TUClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (visibility=TUVisibility? name=ValidID (parameters+=FullJvmFormalParameter parameters+=FullJvmFormalParameter*)? body=XBlockExpression)
	 */
	protected void sequence_TUConstructor(EObject context, TUConstructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((entry?='entry' | exit?='exit') body=XBlockExpression)
	 */
	protected void sequence_TUEntryOrExitActivity(EObject context, TUEntryOrExitActivity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID body=XBlockExpression)
	 */
	protected void sequence_TUExecution(EObject context, TUExecution semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.TU_MODEL_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.TU_MODEL_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.TU_EXECUTION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.TU_EXECUTION__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTUExecutionAccess().getNameValidIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTUExecutionAccess().getBodyXBlockExpressionParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName? importSection=XImportSection? elements+=TUModelElement*)
	 */
	protected void sequence_TUFile(EObject context, TUFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING?)
	 */
	protected void sequence_TUModelDeclaration(EObject context, TUModelDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((lower=INT (upperSet?='..' (upper=INT | upperInf?='*'))?) | any?='*')
	 */
	protected void sequence_TUMultiplicity(EObject context, TUMultiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (visibility=TUVisibility? type=JvmTypeReference name=ValidID)
	 */
	protected void sequence_TUSignalAttribute(EObject context, TUSignalAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID attributes+=TUSignalAttribute*)
	 */
	protected void sequence_TUSignal(EObject context, TUSignal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=TUStateType name=ValidID members+=TUStateMember*)
	 */
	protected void sequence_TUState(EObject context, TUState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     body=XBlockExpression
	 */
	protected void sequence_TUTransitionEffect(EObject context, TUTransitionEffect semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.TU_TRANSITION_EFFECT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.TU_TRANSITION_EFFECT__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTUTransitionEffectAccess().getBodyXBlockExpressionParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (else?='else' | expression=XExpression)
	 */
	protected void sequence_TUTransitionGuard(EObject context, TUTransitionGuard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     trigger=[TUSignal|QualifiedName]
	 */
	protected void sequence_TUTransitionTrigger(EObject context, TUTransitionTrigger semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.TU_TRANSITION_TRIGGER__TRIGGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.TU_TRANSITION_TRIGGER__TRIGGER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTUTransitionTriggerAccess().getTriggerTUSignalQualifiedNameParserRuleCall_1_0_1(), semanticObject.getTrigger());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (from?='from'? vertex=[TUState|QualifiedName])
	 */
	protected void sequence_TUTransitionVertex(EObject context, TUTransitionVertex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID members+=TUTransitionMember*)
	 */
	protected void sequence_TUTransition(EObject context, TUTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (leftOperand=XAdditiveExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpAdd] rightOperand=XMultiplicativeExpression) | 
	 *         (leftOperand=XMultiplicativeExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpMulti] rightOperand=XUnaryOperation) | 
	 *         (leftOperand=XRelationalExpression_XBinaryOperation_1_1_0_0_0 feature=[JvmIdentifiableElement|OpCompare] rightOperand=XOtherOperatorExpression) | 
	 *         (leftOperand=XEqualityExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpEquality] rightOperand=XRelationalExpression) | 
	 *         (leftOperand=XAndExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpAnd] rightOperand=XEqualityExpression) | 
	 *         (leftOperand=XOrExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpOr] rightOperand=XAndExpression) | 
	 *         (leftOperand=XAssignment_XBinaryOperation_1_1_0_0_0 feature=[JvmIdentifiableElement|OpMultiAssign] rightOperand=XAssignment)
	 *     )
	 */
	protected void sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XRelationalExpression(EObject context, XBinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (feature=[JvmIdentifiableElement|FeatureCallID] value=XAssignment) | 
	 *         (assignable=XMemberFeatureCall_XAssignment_1_0_0_0_0 explicitStatic?='::'? feature=[JvmIdentifiableElement|FeatureCallID] value=XAssignment)
	 *     )
	 */
	protected void sequence_XAssignment_XMemberFeatureCall(EObject context, XAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (initExpressions+=XExpression | initExpressions+=XVariableDeclaration)? 
	 *         expression=XExpression? 
	 *         updateExpressions+=XExpression? 
	 *         eachExpression=XBlockExpression
	 *     )
	 */
	protected void sequence_XBasicForLoopExpression(EObject context, XBasicForLoopExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((expressions+=XRAlfStatementSemicolonNotNeeded | expressions+=XRAlfStatementSemicolonNeeded)*)
	 */
	protected void sequence_XBlockExpression(EObject context, XBlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (case=XExpression (then=XBlockExpression | fallThrough?=','))
	 */
	protected void sequence_XCasePart(EObject context, XCasePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         constructor=[JvmConstructor|QualifiedName] 
	 *         typeArguments+=JvmSimpleTypeReference? 
	 *         explicitConstructorCall?='(' 
	 *         (arguments+=XExpression arguments+=XExpression*)?
	 *     )
	 */
	protected void sequence_XConstructorCall(EObject context, XConstructorCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (body=XBlockExpression predicate=XExpression)
	 */
	protected void sequence_XDoWhileExpression(EObject context, XDoWhileExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__PREDICATE));
			if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXDoWhileExpressionAccess().getBodyXBlockExpressionParserRuleCall_2_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getXDoWhileExpressionAccess().getPredicateXExpressionParserRuleCall_5_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         feature=[JvmIdentifiableElement|IdOrSuper] 
	 *         (explicitOperationCall?='(' (featureCallArguments+=XShortClosure | (featureCallArguments+=XExpression featureCallArguments+=XExpression*))?)?
	 *     )
	 */
	protected void sequence_XFeatureCall(EObject context, XFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (declaredParam=FullJvmFormalParameter forExpression=XExpression eachExpression=XBlockExpression)
	 */
	protected void sequence_XForLoopExpression(EObject context, XForLoopExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__FOR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__FOR_EXPRESSION));
			if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__EACH_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__EACH_EXPRESSION));
			if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__DECLARED_PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__DECLARED_PARAM));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXForLoopExpressionAccess().getDeclaredParamFullJvmFormalParameterParserRuleCall_0_0_3_0(), semanticObject.getDeclaredParam());
		feeder.accept(grammarAccess.getXForLoopExpressionAccess().getForExpressionXExpressionParserRuleCall_1_0(), semanticObject.getForExpression());
		feeder.accept(grammarAccess.getXForLoopExpressionAccess().getEachExpressionXBlockExpressionParserRuleCall_3_0(), semanticObject.getEachExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (if=XExpression then=XBlockExpression (else=XIfExpression | else=XBlockExpression)?)
	 */
	protected void sequence_XIfExpression(EObject context, XIfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (static?='static' importedType=[JvmDeclaredType|QualifiedNameInStaticImport] (wildcard?='*' | memberName=ValidID)) | 
	 *         importedType=[JvmDeclaredType|QualifiedName] | 
	 *         importedNamespace=QualifiedNameWithWildcard
	 *     )
	 */
	protected void sequence_XImportDeclaration(EObject context, XImportDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=XMemberFeatureCall_RAlfAssocNavExpression_1_2_0_0_0 right=[TUAssociationEnd|TUAssocEndName])
	 */
	protected void sequence_XMemberFeatureCall(EObject context, RAlfAssocNavExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.RALF_ASSOC_NAV_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.RALF_ASSOC_NAV_EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, XtxtUMLPackage.Literals.RALF_ASSOC_NAV_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtxtUMLPackage.Literals.RALF_ASSOC_NAV_EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXMemberFeatureCallAccess().getRAlfAssocNavExpressionLeftAction_1_2_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXMemberFeatureCallAccess().getRightTUAssociationEndTUAssocEndNameParserRuleCall_1_2_1_0_1(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         memberCallTarget=XMemberFeatureCall_XMemberFeatureCall_1_1_0_0_0 
	 *         explicitStatic?='::'? 
	 *         feature=[JvmIdentifiableElement|IdOrSuper] 
	 *         (explicitOperationCall?='(' (memberCallArguments+=XShortClosure | (memberCallArguments+=XExpression memberCallArguments+=XExpression*))?)?
	 *     )
	 */
	protected void sequence_XMemberFeatureCall(EObject context, XMemberFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=XExpression?)
	 */
	protected void sequence_XReturnExpression(EObject context, XReturnExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (switch=XExpression cases+=XCasePart* default=XBlockExpression?)
	 */
	protected void sequence_XSwitchExpression(EObject context, XSwitchExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=JvmTypeReference name=ValidID right=XExpression? writeable?=';')
	 */
	protected void sequence_XVariableDeclaration(EObject context, XVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (predicate=XExpression body=XBlockExpression)
	 */
	protected void sequence_XWhileExpression(EObject context, XWhileExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__PREDICATE));
			if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXWhileExpressionAccess().getPredicateXExpressionParserRuleCall_3_0(), semanticObject.getPredicate());
		feeder.accept(grammarAccess.getXWhileExpressionAccess().getBodyXBlockExpressionParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
}
